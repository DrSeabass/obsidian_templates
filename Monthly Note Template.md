# ðŸŽ¯ Monthly Goals
| Scope    | Goal           |
| -------- | -------------- |
| Career   | #place_holder  |
| Personal | #place_holder  |
| Health   | #place_holder  |

# ðŸ§­ Monthly Themes
| Scope     | Goal          |
| --------- | ------------- |
| Emotional | #place_holder |
| Strategic | #place_holder |
| Identity  | #place_holder |

# ðŸ“š Weekly Notes
<%*
// Import the utility modules and call them to get the functions
const dateUtils = tp.user.dateUtils();
const noteUtils = tp.user.noteUtils();
const dashboardUtils = tp.user.dashboardUtils();

// Extract the month and year from the filename (assumes format "YYYY-MM")
const filenameDate = tp.file.title.match(/\d{4}-\d{2}/) ? tp.file.title : tp.date.now("YYYY-MM");
const monthDate = window.moment(filenameDate, "YYYY-MM");

// Check if the note already exists and find the next available date if needed
const nextAvailable = noteUtils.findNextAvailableMonthlyNote(app, monthDate, dateUtils);
const finalMonthDate = nextAvailable.date;
const finalPath = nextAvailable.path;

// Move the file to the correct location
try {
  await tp.file.move(finalPath);
  console.log(`Moved file to: ${finalPath}`);
} catch (error) {
  console.error(`Error moving file to ${finalPath}:`, error);
  console.error(`Error details:`, error.message);
}

const year = finalMonthDate.year();
const month = finalMonthDate.month(); // 0-indexed

// Get all weeks that belong to this month using the dateUtils module
const weeksInMonth = dateUtils.getWeeksInMonth(year, month);

// Update the Dashboard with links to the current day, week, and month
dashboardUtils.updateDashboard(app, finalMonthDate, dateUtils);

// Generate links to weekly notes
let weekLinks = '';
for (const weekMonday of weeksInMonth) {
  const weekPath = dateUtils.getWeeklyNotePath(weekMonday);
  weekLinks += `- [[${weekPath}|Week of ${weekMonday.format("MMMM D")}]]\n`;
}

// If no weeks were found, provide a placeholder
if (weekLinks === '') {
  weekLinks = '- No weeks found for this month\n';
}

tR += weekLinks;
%>


## ðŸ““ Notable Wins & Milestones
> Record things worth remembering â€” both logistical and emotional.
> At least one a week, no more than 3 unless something wild happened
* ==REPLACE WITH SOMETHING== #place_holder 

# ðŸš§ Rolled Over Repeatedly
> Review your weekly notes and note any tasks or goals that slipped more than once
* ==REPLACE WITH SOMETHING== #place_holder 

# ðŸ’¡ Insights & Patterns
> What themes, habits, or struggles repeated this month?
* ==REPLACE WITH SOMETHING== #place_holder 

# ðŸ›  Adjustments for Next Month
> What would make next month smoother, easier, or more aligned?
* ==REPLACE WITH SOMETHING== #place_holder 

# Tasks
## Generated by LASTMONTH #place_holder 
## ðŸ” Copied Forward to NEXTMONTH #place_holder 
> List what should be rolled into the next calendar month

- ==REPLACE WITH SOMETHING== #place_holder

# Time Tracking
## Monthly Summary
```dataviewjs
// Get the current file path (assuming it's a monthly note)
const currentFile = dv.current();
const monthPath = currentFile.file.path.replace('.md', '');

// Extract the month from the monthly note path (assuming format like "2025/05-May/2025-05")
const dateMatch = monthPath.match(/(\d{4}-\d{2})$/);
if (!dateMatch) {
  dv.paragraph("Could not extract date from monthly note path");
  return;
}

const monthDate = window.moment(dateMatch[1], "YYYY-MM");

// Helper function to get daily note path
function getDailyNotePath(date) {
  const year = date.format("YYYY");
  const monthName = date.format("MM-MMMM");
  const formattedDate = date.format("YYYY-MM-DD");
  return `${year}/${monthName}/${formattedDate}`;
}

// Get all days in this month
const daysInMonth = [];
const startOfMonth = monthDate.clone().startOf('month');
const endOfMonth = monthDate.clone().endOf('month');

for (let day = startOfMonth.clone(); day <= endOfMonth; day.add(1, 'day')) {
  daysInMonth.push(getDailyNotePath(day.clone()));
}

console.log("Month date:", monthDate.format("YYYY-MM"));
console.log("Days in month:", daysInMonth);

// Parse the time log table
function parseTimeLog(content) {
  console.log("Starting to parse time log from content length:", content ? content.length : 0);
  const result = {
    tagHours: {},
    rawData: [],
    totalHours: 0
  };
  
  try {
    // Extract the time log table using regex
    const tableRegex = /# Time Log\s*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|\s*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|\s*((?:\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|\s*)*)/;
    const tableMatch = content.match(tableRegex);
    
    if (!tableMatch || !tableMatch[1]) {
      return result;
    }
    
    // Process each row of the table
    const rows = tableMatch[1].trim().split('\n');
    
    for (const row of rows) {
      // Skip empty rows
      if (!row.trim()) continue;
      
      // Extract cells from the row
      const cells = row.split('|').map(cell => cell.trim()).filter(cell => cell !== '');
      
      // Skip rows with insufficient data
      if (cells.length < 3) continue;
      
      const startTime = cells[0];
      const endTime = cells[1];
      const typeCell = cells[2];
      const activity = cells.length > 3 ? cells[3] : '';
      const notes = cells.length > 4 ? cells[4] : '';
      
      // Skip rows without valid start/end times
      if (!startTime || !endTime) continue;
      
      // Parse start and end times (assuming format like "08:30" or "8:30")
      const startParts = startTime.split(':').map(part => parseInt(part, 10));
      const endParts = endTime.split(':').map(part => parseInt(part, 10));
      
      if (startParts.length !== 2 || endParts.length !== 2) continue;
      
      const startHour = startParts[0];
      const startMinute = startParts[1];
      const endHour = endParts[0];
      const endMinute = endParts[1];
      
      // Calculate duration in hours
      let durationHours = endHour - startHour;
      let durationMinutes = endMinute - startMinute;
      
      if (durationMinutes < 0) {
        durationHours -= 1;
        durationMinutes += 60;
      }
      
      const duration = durationHours + (durationMinutes / 60);
      
      // Skip entries with negative or zero duration
      if (duration <= 0) continue;
      
      // Extract tags from the type cell
      const tags = [];
      const tagMatches = typeCell.match(/#[a-zA-Z0-9_]+/g);
      
      if (tagMatches) {
        for (const tag of tagMatches) {
          tags.push(tag);
          
          // Add hours to tag totals
          if (!result.tagHours[tag]) {
            result.tagHours[tag] = 0;
          }
          result.tagHours[tag] += duration;
        }
      }
      
      // Add to raw data
      result.rawData.push({
        startTime,
        endTime,
        duration,
        tags,
        activity,
        notes
      });
      
      // Add to total hours
      result.totalHours += duration;
    }
  } catch (error) {
    console.error("Error parsing time log:", error);
  }
  
  return result;
}

// Aggregate time data from multiple notes
async function aggregateTimeLogs(notePaths) {
  const result = {
    tagHours: {},
    rawData: [],
    totalHours: 0,
    noteData: {} // Data organized by note
  };
  
  console.log("Starting to aggregate time logs from paths:", notePaths);
  
  try {
    for (const notePath of notePaths) {
      try {
        console.log(`Attempting to load note: ${notePath}.md`);
        
        // Try to load the note content
        const noteContent = await dv.io.load(notePath + ".md");
        
        if (!noteContent) {
          console.log(`Note content is empty or null for: ${notePath}.md`);
          continue;
        }
        
        console.log(`Successfully loaded note: ${notePath}.md`);
        
        // Parse the time log
        const timeLog = parseTimeLog(noteContent);
        
        // Log the parsed time data
        console.log(`Parsed time data for ${notePath}:`, {
          totalHours: timeLog.totalHours,
          tagCount: Object.keys(timeLog.tagHours).length,
          tags: Object.keys(timeLog.tagHours)
        });
        
        // Add to aggregated data
        for (const tag in timeLog.tagHours) {
          if (!result.tagHours[tag]) {
            result.tagHours[tag] = 0;
          }
          result.tagHours[tag] += timeLog.tagHours[tag];
        }
        
        // Add raw data with note reference
        for (const entry of timeLog.rawData) {
          result.rawData.push({
            ...entry,
            notePath
          });
        }
        
        // Add to total hours
        result.totalHours += timeLog.totalHours;
        
        // Store data by note
        result.noteData[notePath] = timeLog;
      } catch (error) {
        // Note might not exist, just log the error and continue
        console.error(`Error processing note ${notePath}:`, error.message);
        continue;
      }
    }
    
    console.log("Aggregation complete. Total hours:", result.totalHours);
    console.log("Tags found:", Object.keys(result.tagHours));
    console.log("Notes processed:", Object.keys(result.noteData).length);
    
  } catch (error) {
    console.error("Error in aggregateTimeLogs function:", error);
  }
  
  return result;
}

// Generate chart code for monthly summary
function generateMonthlySummaryChart(timeData) {
  try {
    // Sort tags alphabetically
    const sortedTags = Object.keys(timeData.tagHours).sort();
    
    // Format hours to 1 decimal place
    const formatHours = (hours) => Math.round(hours * 10) / 10;
    
    // Generate a bar chart for monthly summary
    return `\`\`\`chart
type: bar
labels: [${sortedTags.map(tag => `"${tag}"`).join(', ')}]
series:
  - data: [${sortedTags.map(tag => formatHours(timeData.tagHours[tag])).join(', ')}]
width: 100%
labelColors: true
fill: true
legend: false
\`\`\``;
  } catch (error) {
    console.error("Error generating chart code:", error);
    return "```\nError generating chart\n```";
  }
}

// Aggregate time data from all daily notes in the month
const timeData = await aggregateTimeLogs(daysInMonth);

// Generate and render the chart
const summaryChart = generateMonthlySummaryChart(timeData);
dv.paragraph(summaryChart);
```

## Weekly Breakdown
```dataviewjs
// Get the current file path (assuming it's a monthly note)
const currentFile = dv.current();
const monthPath = currentFile.file.path.replace('.md', '');

// Extract the month from the monthly note path (assuming format like "2025/05-May/2025-05")
const dateMatch = monthPath.match(/(\d{4}-\d{2})$/);
if (!dateMatch) {
  dv.paragraph("Could not extract date from monthly note path");
  return;
}

const monthDate = window.moment(dateMatch[1], "YYYY-MM");

// Helper functions for date and path handling
function getWeekMonth(mondayDate) {
  const mondayMonth = mondayDate.month();
  const mondayYear = mondayDate.year();
  
  // Get the last day of the month that contains Monday
  const lastDayOfMonth = window.moment([mondayYear, mondayMonth]).endOf('month');
  
  // If the last day of the month is Monday (1) or Tuesday (2)
  if (lastDayOfMonth.day() === 1 || lastDayOfMonth.day() === 2) {
    // Check if Monday is the last Monday or Tuesday of the month
    if (mondayDate.date() > lastDayOfMonth.date() - 7) {
      // This week belongs to the next month
      const nextMonth = mondayDate.clone().add(1, 'month');
      return nextMonth;
    }
  }
  
  // Otherwise, the week belongs to the month its Monday is in
  return mondayDate.clone();
}

function getWeeksInMonth(year, month) {
  const weeks = [];
  
  // Find the first Monday of the month
  let firstMonday = window.moment([year, month, 1]);
  while (firstMonday.day() !== 1) {
    firstMonday.add(1, 'day');
  }
  
  // Check if the last week of the previous month belongs to this month
  const prevMonth = window.moment([year, month, 1]).subtract(1, 'day');
  const prevMonthLastDay = prevMonth.clone().endOf('month');
  
  // If the last day of the previous month is Monday (1) or Tuesday (2)
  if (prevMonthLastDay.day() === 1 || prevMonthLastDay.day() === 2) {
    // Find the Monday of the last week of the previous month
    let lastMondayOfPrevMonth = prevMonthLastDay.clone();
    while (lastMondayOfPrevMonth.day() !== 1) {
      lastMondayOfPrevMonth.subtract(1, 'day');
    }
    
    // Check if this week belongs to the current month
    const weekMonth = getWeekMonth(lastMondayOfPrevMonth);
    if (weekMonth.month() === month && weekMonth.year() === year) {
      weeks.push(lastMondayOfPrevMonth);
    }
  }
  
  // Add all Mondays in the current month
  let currentMonday = firstMonday.clone();
  while (currentMonday.month() === month) {
    // Check if this week belongs to this month
    const weekMonth = getWeekMonth(currentMonday);
    if (weekMonth.month() === month && weekMonth.year() === year) {
      weeks.push(currentMonday.clone());
    }
    currentMonday.add(7, 'days');
  }
  
  return weeks;
}

// Helper function to get daily note path
function getDailyNotePath(date) {
  const year = date.format("YYYY");
  const monthName = date.format("MM-MMMM");
  const formattedDate = date.format("YYYY-MM-DD");
  return `${year}/${monthName}/${formattedDate}`;
}

// Get all weeks in this month
const weeksInMonth = getWeeksInMonth(monthDate.year(), monthDate.month());

// Create a map of week start dates to arrays of daily note paths for that week
const weekToDailyPaths = {};

for (const monday of weeksInMonth) {
  const weekKey = monday.format("YYYY-MM-DD");
  weekToDailyPaths[weekKey] = [];
  
  // Add all days in this week
  for (let i = 0; i < 7; i++) {
    const day = monday.clone().add(i, 'days');
    // Only include days that are in the current month
    if (day.month() === monthDate.month() && day.year() === monthDate.year()) {
      weekToDailyPaths[weekKey].push(getDailyNotePath(day));
    }
  }
}

console.log("Weekly Breakdown - Month date:", monthDate.format("YYYY-MM"));
console.log("Weekly Breakdown - Weeks in month:", Object.keys(weekToDailyPaths));
console.log("Weekly Breakdown - Daily paths by week:", weekToDailyPaths);

// Parse the time log table
function parseTimeLog(content) {
  const result = {
    tagHours: {},
    rawData: [],
    totalHours: 0
  };
  
  try {
    // Extract the time log table using regex
    const tableRegex = /# Time Log\s*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|\s*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|\s*((?:\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|[^\|]*\|\s*)*)/;
    const tableMatch = content.match(tableRegex);
    
    if (!tableMatch || !tableMatch[1]) {
      return result;
    }
    
    // Process each row of the table
    const rows = tableMatch[1].trim().split('\n');
    
    for (const row of rows) {
      // Skip empty rows
      if (!row.trim()) continue;
      
      // Extract cells from the row
      const cells = row.split('|').map(cell => cell.trim()).filter(cell => cell !== '');
      
      // Skip rows with insufficient data
      if (cells.length < 3) continue;
      
      const startTime = cells[0];
      const endTime = cells[1];
      const typeCell = cells[2];
      const activity = cells.length > 3 ? cells[3] : '';
      const notes = cells.length > 4 ? cells[4] : '';
      
      // Skip rows without valid start/end times
      if (!startTime || !endTime) continue;
      
      // Parse start and end times (assuming format like "08:30" or "8:30")
      const startParts = startTime.split(':').map(part => parseInt(part, 10));
      const endParts = endTime.split(':').map(part => parseInt(part, 10));
      
      if (startParts.length !== 2 || endParts.length !== 2) continue;
      
      const startHour = startParts[0];
      const startMinute = startParts[1];
      const endHour = endParts[0];
      const endMinute = endParts[1];
      
      // Calculate duration in hours
      let durationHours = endHour - startHour;
      let durationMinutes = endMinute - startMinute;
      
      if (durationMinutes < 0) {
        durationHours -= 1;
        durationMinutes += 60;
      }
      
      const duration = durationHours + (durationMinutes / 60);
      
      // Skip entries with negative or zero duration
      if (duration <= 0) continue;
      
      // Extract tags from the type cell
      const tags = [];
      const tagMatches = typeCell.match(/#[a-zA-Z0-9_]+/g);
      
      if (tagMatches) {
        for (const tag of tagMatches) {
          tags.push(tag);
          
          // Add hours to tag totals
          if (!result.tagHours[tag]) {
            result.tagHours[tag] = 0;
          }
          result.tagHours[tag] += duration;
        }
      }
      
      // Add to raw data
      result.rawData.push({
        startTime,
        endTime,
        duration,
        tags,
        activity,
        notes
      });
      
      // Add to total hours
      result.totalHours += duration;
    }
  } catch (error) {
    console.error("Error parsing time log:", error);
  }
  
  return result;
}

// Aggregate time data from multiple notes
async function aggregateTimeLogs(notePaths) {
  const result = {
    tagHours: {},
    rawData: [],
    totalHours: 0,
    noteData: {} // Data organized by note
  };
  
  console.log("Weekly Breakdown - Starting to aggregate time logs from paths:", notePaths);
  
  try {
    for (const notePath of notePaths) {
      try {
        console.log(`Weekly Breakdown - Attempting to load note: ${notePath}.md`);
        
        // Try to load the note content
        const noteContent = await dv.io.load(notePath + ".md");
        
        if (!noteContent) {
          console.log(`Weekly Breakdown - Note content is empty or null for: ${notePath}.md`);
          continue;
        }
        
        console.log(`Weekly Breakdown - Successfully loaded note: ${notePath}.md`);
        
        // Parse the time log
        const timeLog = parseTimeLog(noteContent);
        
        // Log the parsed time data
        console.log(`Weekly Breakdown - Parsed time data for ${notePath}:`, {
          totalHours: timeLog.totalHours,
          tagCount: Object.keys(timeLog.tagHours).length,
          tags: Object.keys(timeLog.tagHours)
        });
        
        // Add to aggregated data
        for (const tag in timeLog.tagHours) {
          if (!result.tagHours[tag]) {
            result.tagHours[tag] = 0;
          }
          result.tagHours[tag] += timeLog.tagHours[tag];
        }
        
        // Add raw data with note reference
        for (const entry of timeLog.rawData) {
          result.rawData.push({
            ...entry,
            notePath
          });
        }
        
        // Add to total hours
        result.totalHours += timeLog.totalHours;
        
        // Store data by note
        result.noteData[notePath] = timeLog;
      } catch (error) {
        // Note might not exist, just log the error and continue
        console.error(`Weekly Breakdown - Error processing note ${notePath}:`, error.message);
        continue;
      }
    }
    
    console.log("Weekly Breakdown - Aggregation complete. Total hours:", result.totalHours);
    console.log("Weekly Breakdown - Tags found:", Object.keys(result.tagHours));
    console.log("Weekly Breakdown - Notes processed:", Object.keys(result.noteData).length);
    
  } catch (error) {
    console.error("Weekly Breakdown - Error in aggregateTimeLogs function:", error);
  }
  
  return result;
}

// Aggregate time data for each week
async function aggregateWeeklyData() {
  const weeklyData = {};
  const allTags = new Set();
  
  for (const weekKey in weekToDailyPaths) {
    const dailyPaths = weekToDailyPaths[weekKey];
    const weekData = await aggregateTimeLogs(dailyPaths);
    
    weeklyData[weekKey] = weekData;
    
    // Collect all tags
    for (const tag in weekData.tagHours) {
      allTags.add(tag);
    }
  }
  
  return { weeklyData, allTags: Array.from(allTags).sort() };
}

// Generate chart code for weekly breakdown
function generateWeeklyBreakdownChart(weeklyData, allTags) {
  try {
    // Format hours to 1 decimal place
    const formatHours = (hours) => Math.round(hours * 10) / 10;
    
    // Create series for each week
    const weekSeries = Object.keys(weeklyData).sort().map(weekKey => {
      const weekData = weeklyData[weekKey];
      const weekDate = window.moment(weekKey, "YYYY-MM-DD");
      
      return {
        title: `Week of ${weekDate.format("MMM D")}`,
        data: allTags.map(tag => {
          return weekData.tagHours[tag] ? formatHours(weekData.tagHours[tag]) : 0;
        })
      };
    });
    
    return `\`\`\`chart
type: bar
labels: [${allTags.map(tag => `"${tag}"`).join(', ')}]
series:
${weekSeries.map(series => `  - data: [${series.data.join(', ')}]`).join('\n')}
width: 100%
labelColors: true
legend: false
\`\`\``;
  } catch (error) {
    console.error("Error generating chart code:", error);
    return "```\nError generating chart\n```";
  }
}

// Aggregate data and generate chart
const { weeklyData, allTags } = await aggregateWeeklyData();
const breakdownChart = generateWeeklyBreakdownChart(weeklyData, allTags);
dv.paragraph(breakdownChart);
